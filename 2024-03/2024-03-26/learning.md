# Rotate Array

int 配列nums, k 回右にローテーションする、kが正の場合


例1
nums = [1, 2, 3, 4, 5, 6, 7], k=3
output = [5, 6, 7, 1, 2, 3, 4]
rotate 1 steps to the right: [7, 1, 2, 3, 4, 5, 6]
rotate 2 steps to the right: [6, 7, 1, 2, 3, 4, 5]
rotate 3 steps to the right: [5, 6, 7, 1, 2, 3, 4]

例2
nums = [-1, -100, 3, 99], k=2
output = [3, 99, -1, -100]
rotate 1 steps to right: [99, -1, -100, 3]
rotate 1 steps to right: [3, 99, -1, -100]

## コードを書く前に考えたこと
見た感じ、末尾の文字をとって、前に出す。という操作の繰り返しで解ける。
kの範囲は0<=k<=10^5 なので、for で回す訳には行かない
nums のlength 回rotate すると元の配列に戻る

仮説：nums のあまり分rotateすれば良い？
例1の場合len(nums)=7, k=3 なのでk%len(nums)=3%7=3
この場合、kはlen(nums) の回数分rotateすればOKだけど、forをつかわなくていい方法を探したい
例1, k=3 の場合outputは
[1,2,3,4], [5,6,7] の配列の合体になっている
例2, k=2 の場合outputは
[3,99], [-1, -100] の合体になっている

仮説：k の数分末尾から取り出して、前の配列と逆にして合体させると回答になる？
例1をk=1,2,3,4,5,6,7 で試してみる
k=1 の時
output=[7, 1, 2, 3, 4, 5, 6], 末尾から1つ取り出して[7]、前半後半逆にして合体したものと同じ
k=2 の時
output=[6, 7, 1, 2, 3, 4, 5], 末尾から2つ取り出して[6,7]、前半後半逆にして合体したものと同じ
k=4 の時
[4, 5, 6, 7, 1, 2, 3]
k=5
[3, 4, 5, 6, 7, 1, 2]
k=6
[2, 3, 4, 5, 6, 7, 1]
k=7
[1, 2, 3, 4, 5, 6, 7]
とりあえず正しいと言えそう。あまりがない時はそのまま返却すればいいかも

考え方は正しいけど、nums を関数内部で更新することができないため、この手は取れない
直接更新する必要がある


## 解答を投げた時の考えたこと
- 割り切れる場合を完全に忘れてた…

## 解答を見て考えたこと
逆順にすることを効果的に行うと、うまくいくらしい

このアルゴリズムの具体例を挙げて解説します。配列nums = [1, 2, 3, 4, 5, 6, 7]を右にk = 3回転させる場合を考えましょう。

全体の逆順化:

まず、配列全体を逆順にします。
元の配列: [1, 2, 3, 4, 5, 6, 7]
逆順後: [7, 6, 5, 4, 3, 2, 1]
前半の逆順化:

次に、先頭からk個の要素（この例では3個）を逆順にします。
逆順前: [7, 6, 5 ||  4, 3, 2, 1]
逆順後: [5, 6, 7 ||  4, 3, 2, 1]
後半の逆順化:

最後に、残りの部分を逆順にします。
逆順前: [5, 6, 7 ||  4, 3, 2, 1]
逆順後: [5, 6, 7 ||  1, 2, 3, 4]
結果として、配列は右に3回転され、最終的な配列は[5, 6, 7, 1, 2, 3, 4]となります。

このアルゴリズムは、逆順操作を3回適用することで配列を効率的に回転させるというアイデアに基づいています。この方法では、追加のメモリを使用せずに、配列の一部を回転させることができます。また、各要素が最大で一度だけ移動されるため、時間効率も良いです。
