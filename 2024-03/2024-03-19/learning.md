# RemoveElement

int配列nums, int val が与えられる
val があるnums の箇所をin-place で削除する
要素の順序は変えてもよい。その場合、numsの中でvalと等しくない要素の数を返す。

numsの中でvalと等しくない要素の数をkとする：

配列numsを、numsの最初のk個の要素にvalと等しくない要素が含まれるように変更する。
numsの残りの要素は、numsのサイズと同様に重要ではない。
kを返す。

# コードを書く前に考えたこと
- nums の中にval と異なる数字がいくつあるかを確認する
- nums の中身は変更してもよく、とにかく異なる数字がいくつあるかを確認する
- nums をforr でループさせてval と等しくなければanswer++ すれば良いのでは？
- val と異なれば新しい配列に入れ込む
- そういうことではなさそう
  - in-place を理解していない？
- 削除された後の配列のlength を返すのか

# 解いた後に考えたこと
- 問題のして欲しいことが不明
- 他の人のコードを見たところ、
  - nums の分ループを回す
  - j->異なる数字の個数
  - nums のi番目がval と等しくないのであればnums[j]=nums[i], nums[i]=nums[j] にする
  - jをインクリメントする
- nums を更新する
- つまり、nums の配列要素を入れ替えて、異なる文字だけ前に出せってことだった

# 実装時間
- 問題読む：5分
- 実装：20分（タイムオーバー）
