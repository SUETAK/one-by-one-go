# Rotate Array

int 配列nums, k 回右にローテーションする、kが正の場合


例1
nums = [1, 2, 3, 4, 5, 6, 7], k=3
output = [5, 6, 7, 1, 2, 3, 4]
rotate 1 steps to the right: [7, 1, 2, 3, 4, 5, 6]
rotate 2 steps to the right: [6, 7, 1, 2, 3, 4, 5]
rotate 3 steps to the right: [5, 6, 7, 1, 2, 3, 4]

例2
nums = [-1, -100, 3, 99], k=2
output = [3, 99, -1, -100]
rotate 1 steps to right: [99, -1, -100, 3]
rotate 1 steps to right: [3, 99, -1, -100]

## コードを書く前に考えたこと
見た感じ、末尾の文字をとって、前に出す。という操作の繰り返しで解ける。
kの範囲は0<=k<=10^5 なので、for で回す訳には行かない
nums のlength 回rotate すると元の配列に戻る

仮説：nums のあまり分rotateすれば良い？
例1の場合len(nums)=7, k=3 なのでk%len(nums)=3%7=3
この場合、kはlen(nums) の回数分rotateすればOKだけど、forをつかわなくていい方法を探したい
例1, k=3 の場合outputは
[1,2,3,4], [5,6,7] の配列の合体になっている
例2, k=2 の場合outputは
[3,99], [-1, -100] の合体になっている

仮説：k の数分末尾から取り出して、前の配列と逆にして合体させると回答になる？
例1をk=1,2,3,4,5,6,7 で試してみる
k=1 の時
output=[7, 1, 2, 3, 4, 5, 6], 末尾から1つ取り出して[7]、前半後半逆にして合体したものと同じ
k=2 の時
output=[6, 7, 1, 2, 3, 4, 5], 末尾から2つ取り出して[6,7]、前半後半逆にして合体したものと同じ
k=4 の時
[4, 5, 6, 7, 1, 2, 3]
k=5
[3, 4, 5, 6, 7, 1, 2]
k=6
[2, 3, 4, 5, 6, 7, 1]
k=7
[1, 2, 3, 4, 5, 6, 7]
とりあえず正しいと言えそう。あまりがない時はそのまま返却すればいいかも

考え方は正しいけど、nums を関数内部で更新することができないため、この手は取れない
直接更新する必要がある


## 解答を投げた時の考えたこと
- 割り切れる場合を完全に忘れてた…

## 解答を見て考えたこと

