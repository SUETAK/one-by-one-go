# Remove Duplicates from Sorted Array

int配列が与えられる。non-decreasing order でソートされている
duplicates な値をin-place で削除する
削除した後は２個までにする
array の長さは変えてはいけない。


# コードを書く前に考えたこと
- １個だけにしたやつの２個版
- k はユニークな場合と2回目の同じ数字の時にインクリメントされる
  - 位置の入れ替えは、場合わけ
    - 次の数字がユニークな場合
      - カウント回数が2回以外の場合、
        - num[k]をvで更新
      - kをインクリメント
      - 前回の数字を更新
    - カウントが2回以上で、次の数字も同じ場合
      - kは更新しない


# コードを書きながら考えたこと
- previousValue だけでみると辛い
- i+1 の値まで見ればいいのでは
- 更新する時っていつ？
  - 0, 0, 0, 1
  - 0, 0, 0, 0, 1 -> 0, 0, 1, 0, 0 : k=3 を1に更新
  - 0, 0, 0, 1, 1 -> 0, 0, 1, 1, 0 : k=3, k=4 を1に更新

# １時間立ったので答えをみる
- しゃくとり法をちゃんと理解しないと問題の本質的理解ができない。
- 明日はしゃくとり法をやる


# 答えの解説
jはポインターで、numsに値を追加する場所を追跡する。

このアプローチは、前の2つの値と現在の値を比較するif条件を中心に展開される。
もし前の2つの値（nums[j - 1]とnums[j - 2]）が異なっていれば、
私たちの値が何であるかは問題ではないので、それを追加します。
もし私たちの現在の値（nums[i]）が前の値（nums[j - 1]）と異なっていれば、
重複することなく追加することができます。

len(nums)<2であれば、numsの長さを返すだけなので、重複は1つもありません。

# しゃくとり法かどうかの見分け方
- 他のarray を使ってはいけない
- O(1) で修正する必要がある
↓
- しゃくとり法の条件と一致する
- [参考](https://qiita.com/drken/items/ecd1a472d3a0e7db8dce)
