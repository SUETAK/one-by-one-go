Given a string s, find the length of the longest substring without repeating characters.

string 型のs が与えられます。
繰り返されていない最も長いsubstringの長さを出せ


例)
s= "abcabcbb"
abc -> 3
output = 3

s = "bbbbb"
b -> 1
output = 1

s = "pwwkew"
pw -> 2
wke -> 3
wkew -> wが2つあるのでダメ
output = 3

# コードを書く前に考えたこと
- string を１文字づつ取得して格納していけば良さそう
- 2つめの文字が出てきたら値を保存。改めて回し始める
- 文字列は保存せず、値だけ保存。string は初期化する

# コードを書いてる途中で気づいたこと
- 文字が２回連続したらダメ？

# コードを書き終わった後、答えをみて再チャレンジ
"dvdf" の答えが3 である意味がわからなかった
substring の意味を理解できてなかった
"dvdf"-> d, dv, dvd, dvdf, vd, vdf, df, f
重複した文字のない連続した文字列の長さを返却する。
"vdf" は重複がない最も長い文字列

愚直全部やると時間が足りなくなる
原理的に最大の数になったらやめる必要がある

例えば"dvdf" なら最大は4
d -> 1 -> 4-1=3
dv -> 2
dvd -> 次の文字
2文字目の最大値は4-1 で3なので、3になったタイミングで終わり
3文字目の最大値は4-2 で2なので、もしすでにlength が2以上ならやらなくていい

いい感じにbreak できないかと思ったけど、最後の超長い文字列に勝てなかった

# わからんので答えみる
https://www.code-recipe.com/post/longest-substring-without-repeating-characters

このアルゴリズムには以下のステップがある：

与えられた文字列sに対して、すべての可能な部分文字列を生成する。
2つのループを使うことで、すべての可能な部分文字列を生成することができる。
外側のループを固定し、内側のループ（2番目のループ）のインデックスを移動して、
可能性のあるすべての部分文字列を生成する（詳細はコードを参照）。

ループを使って部分文字列を取得したら（ステップ1で説明）、
現在の部分文字列が明確な文字だけを含んでいるか、重複しているかをチェックすることができる。
これは、別のループを使って得られた部分文字列のすべての文字を調べ、ハッシュマップに追加することでできる。

3回目のループを繰り返す間に、ハッシュマップにすでにある文字があれば、
その部分文字列には重複文字が含まれていることになる。
そうでなければ、部分文字列の文字はすべて一意である。

部分文字列に重複文字が含まれる場合は、現在の部分文字列をスキップし、結果の計算には考慮しない。

部分文字列がすべての一意な文字を含む場合、現在の部分文字列の長さが、これまでに得られたすべての一意な文字の部分文字列の長さよりも大きいかどうかをチェックする。そうであれば結果を更新し、そうでなければ次の部分文字列に進み、ステップ1～5を繰り返す。

このアルゴリズムの時間複雑度はO(n^3)である。これは、3つのループがあるためである。

windowを使うと処理をもっと軽くすることができる
https://www.youtube.com/watch?v=kD3iRlxuN6g&t=3s
