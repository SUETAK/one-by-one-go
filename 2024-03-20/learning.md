# Remove Duplicates from Sorted Array
整数の配列 nums が減らない順にソートされている場合、
各要素が一意に一度だけ現れるように、 重複をその場で取り除く。
要素の相対順序は同じに保つ。
そして nums に含まれる一意な要素の数を返す。

numsのユニークな要素の数をkとすると、受理されるためには以下のことをする必要がある：
- numsの最初のk個の要素に、numsに最初に存在した順番でユニークな要素が含まれるように、配列numsを変更する。
  - nums の残りの要素は nums のサイズと同様に重要ではない。
- kを返す。

# 例
Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]


# 問題を解く前に考えたこと 2:15~
- 昨日やった問題と同様にnums の要素を更新しつつ、kを返却する
- 今回は、要素が重複した場合に、前から順番に1つにして返却する
- map を作成して、range 使ってループ回して前から更新していけばいいかな？
  - 順序が保存されないからダメか
- 相対順序を保つという条件から見て、同じ数字は固まっていそう
- nums をrange でループさせる
  - k=1 から開始
  - 2回目に出た数字のindex を保存
  - 2回目に出た数字を保存
  - 数字と異なるものが出たらkをインクリメント
  - ２度目のindex と初めて出た数字のindex を交換
  - 同じ数字が出たカウントを初期化

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Input: nums = [0,-999,1,-999,-999,2,-999,3,-999,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
