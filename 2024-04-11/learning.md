# Gas Station

環状ルート上にn個のガソリンスタンドがあり、i番目のガソリンスタンドでのガス量をgas[i]とする。

あなたは無制限のガスタンクを持つ車を持っており，
i番目のガソリンスタンドから
次の(i + 1)番目のガソリンスタンドまで移動するには cost[i]のガソリン代がかかる．
あなたはガソリンスタンドの1つでガソリンを空にした状態で旅を始める．

2つの整数配列gasとcostが与えられたとき、
時計回りに1周できれば出発地のガソリンスタンドのインデックスを返し、
そうでなければ-1を返す。解が存在する場合、それは一意であることが保証される。

# 考えたこと
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
ダメな場合は先頭を一番後ろに移動させて、同じようにループを回す
それだと計算量がなぁ

そもそも、gas[i] < cost[i] の場所からは始められない
途中でダメになるパターンもありうる
配列は1万なので全部計算してたら時間が足りないかも

累積和を使ってみる？
gas, cost の累積和を作成する O(N)
gas[i] > cost[i] になるindex を配列に記録しておく
最後の値がgas < cost なら-1
記録した配列から開始。
gas, const の配列を[i:, :i] に書き換えてスタート
最後まで到達したらi を返す


- sum(gas) < sum(cost) => -1
  - ループ中にそうなったら終了？
  - 


